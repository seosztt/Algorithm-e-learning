# 재귀 함수

- 재귀 함수(Recursive Function)란 **자기 자신을 다시 호출하는 함수**를 의미합니다.

- 재귀 함수를 문제 풀이에서 사용할 때는 재귀 함수의 종료 조건을 반드시 명시해야 합니다.
- 종료 조건을 제대로 명시하지 않으면 함수가 무한히 호출될 수 있습니다.

## 재귀 함수 사용의 유의 사항

- 재귀 함수를 잘 활용하면 복잡한 알고리즘을 간결하게 작성할 수 있습니다.
  - 단, 오히려 다른 사람이 이해하기 어려운 형태의 코드가 될 수도 있으므로 신중하게 사용해야 합니다.
- 모든 <u>재귀 함수는 반복문을 이용하여 동일한 기능을 구현</u>할 수 있습니다.
- 재귀 함수가 반복문보다 유리한 경우도 있고 불리한 경우도 있습니다.
- 컴퓨터가 함수를 연속적으로 호출하면 컴퓨터 메모리 내부의 스택 프레임에 쌓입니다.
  - 그래서 스택을 사용해야 할 때 구현상 **스택 라이브러리 대신에 재귀 함수를 이용**하는 경우가 많습니다.



# 실전에서 유용한 Python Standard Library

- 내장 함수: 기본 입출력 함수부터 정렬 함수까지 기본적인 함수들을 제공합니다.
  - 파이썬 프로그램을 작성할 때 없어서는 안 되는 필수적인 기능을 포함하고 있습니다.
- itertools: 파이썬에서 반복되는 형태의 데이터를 처리하기 위한 유용한 기능들을 제공합니다.
  - 특히 순열과 조합 라이브러리는 코딩 테스트에서 자주 사용됩니다.
- heapq: 힙(Heap) 자료구조를 제공합니다.
  - 일반적으로 우선순위 큐 기능을 구현하기 위해 사용됩니다.

- bisect: 이진 탐색(Binary Search) 기능을 제공합니다.
- collectioins: 덱(deque), 카운터(Counter) 등의 유용한 자료구조를 포함합니다.
- math: 필수적인 수학적 기능을 제공합니다.
  - 팩토리얼, 제곱근, 최대공약수(GCD), 삼각함수 관련 함수부터 파이(pi)와 같은 상수를 포함합니다.



# 소수 판별 알고리즘

- 어떠한 자연수가 소수인지 아닌지 판별해야 하는 문제가 자주 출제됩니다.

## 기본적인 알고리즘 성능 분석

- 2부터 X-1까지의 모든 자연수에 대하여 연산을 수행해야 합니다.
  - 모든 수를 하나씩 확인한다는 점에서 시간 복잡도는 O(X)입니다.

## 약수의 성질

- **모든 약수가 가운데 약수를 기준으로 곱셈 연산에 대해 대칭**을 이루는 것을 알 수 있습니다.
- 따라서 우리는 특정한 자연수의 모든 약수를 찾을 때 가운데 약수(제곱근)까지만 확인하면 됩니다.

## 개선된 알고리즘 성능 분석

- 2부터 X의 제곱근(소수점 이하 무시)까지의 모든 자연수에 대하여 연산을 수행해야 합니다.
  - 시간 복잡도는 O(N^1/2)입니다.

## 다수의 소수 판별

- <u>특정한 수의 범위 안에 존재하는 모든 소수</u>를 찾으려면 **에라토스테네스의 체 알고리즘**을 사용할 수 있습니다.

## 에라토스테네스의 체 알고리즘

- <u>다수의 자연수에 대하여 소수 여부를 판별</u>할 때 사용하는 대표적인 알고리즘입니다.
- 에라토스테네스의 체는 N보다 작거나 같은 모든 소수를 찾을 때 사용할 수 있습니다.
- 에라토스테네스의 체 알고리즘의 **구체적인 동작 과정**은 다음과 같습니다.
  1. 2부터 N까지의 모든 자연수를 나열한다.
  2. 남은 수 중에서 아직 처리하지 않은 가장 작은 수 i를 찾는다.
  3. 남은 수 중에서 i의 배수를 모두 제거한다. (i는 제거하지 않는다).
  4. 더 이상 반복할 수 없을 때까지 2번과 3번의 과정을 반복한다.

## 에라토스테네스의 체 알고리즘 성능 분석

- 에라토스테네스의 체 알고리즘의 시간 복잡도는 사실상 선형 시간에 가가울 정도로 매우 빠릅니다.
  - 시간 복잡도는 O(NloglogN)입니다.
- 에라토스테네스의 체 알고리즘은 다수의 소수를 찾아야 하는 문제에서 효과적으로 사용될 수 있습니다.
  - 하지만 각 자연수에 대한 소수 여부를 저장해야 하므로 **메모리가 많이 필요**합니다.
  - **10억**이 소수인지 아닌지 판별해야 할 때 에라토스테네스의 체를 사용하면 메모리 매우 비효율적으로 사용하게 된다.



# 동적계획법 (Dynamic Programming)

- 메모리를 적절히 사용하여 수행 시간 효율성을 비약적으로 향상시키는 방법입니다.
- 이미 계산된 결과(작은 문제)는 별도의 메모리 영역에 저장하여 다시 계산하지 않도록 합니다.
- 구현은 일반적으로 두 가지 방식(탑다운과 보텀업)으로 구성됩니다.
- 일반적인 프로그래밍 분야에서 동적(Dynamic)의 의미
  - 자료구조에서 동적 할당(Dynamic Allocation)은 '**프로그램이 실행되는 도중에 실행에 필요한 메모리를 할당하는 기법**'을 의미합니다.
  - 반면에 **다이나믹 프로그래밍**에서 '다이나믹'은 **별다른 의미 없이 사용된 단어**입니다.

## Dynamic Programming의 조건

- Dynamic Programming은 문제가 다음의 조건을 만족할 때 사용할 수 있습니다.
  1. 최적 부분 구조 (Optimal Substructure)
     - 큰 문제를 작은 문제로 나눌 수 있으며 작은 문제의 답을 모아서 큰 문제를 해결할 수 있습니다.
  2. 중복되는 부분 문제 (Overlapping Subproblem)
     - 동일한 작은 문제를 반복적으로 해결해야 합니다.

## 피보나치 수열

- **점화식**이란 <u>인접한 항들 사이의 관계식</u>을 의미합니다.
- 피보나치 수열을 점화식으로 표현하면 다음과 같습니다.
  - a_n=a_n-1 + a_n-2, a_1 = 1, a_2 = 1

### 피보나치 수열의 시간 복잡도 분석

- 단순 재귀 함수로 피보나치 수열을 해결하면 지수 시간 복잡도를 가지게 됩니다.
- f(2)가 여러 번 호출됩니다. (중복되는 부분 문제)
- 시간 복잡도는 다음과 같습니다.
  - 세타 표기법: θ(1.618…^N)
  - 빅오 표기법: O(2^N)
- 빅오 표기법을 기준으로 f(30)을 계산하기 위해 약 10억가량의 연산을 수행해야 합니다.

### 피보나치 수열의 효율적인 해법: Dynamic Programming

- 다이나믹 프로그래밍의 사용 조건을 만족하는지 확인합니다.
  1. 최적 부분 구조: 큰 문제를 작은 문제로 나눌 수 있습니다.
  2. 중복되는 부분 문제: 동일한 작은 문제를 반복적으로 해결합니다.
- 피보나치 수열은 다이나믹 프로그래밍의 사용 조건을 만족합니다.

## 메모이제이션 (Memoization)

- 하향식(탑다운방식)에 사용된다.
- 메모이제이션은 다이나믹 프로그래밍을 구현하는 방법 중 하나입니다.
- 한 번 계산한 결과를 메모리 공간에 메모하는 기법입니다.
  - 같은 문제를 다시 호출하면 메모했던 결과를 그대로 가져옵니다.
  - 값을 기록해 놓는다는 점에서 캐싱(Caching)이라고도 합니다.

## 탑다운 vs 보텀업

- 탑다운(메모이제이션) 방식은 **하향식**이라고도 하며 보텀업 방식은 **상향식**이라고도 합니다.
- 다이나믹 프로그래밍의 전형적인 형태는 보텀업 방식입니다.
  - 결과 저장용 리스트(혹은 배열)는 **DP테이블**이라고 부릅니다.
- 엄밀히 말하면 메모이제이션은 <u>이전에 계산된 결과를 일시적으로 기록해 놓는 넓은 개념을 의미</u>합니다.
  - 따라서 메모이제이션은 다이나믹 프로그래밍에 국한된 개념은 아닙니다.
  - 한 번 계산된 결과를 담아 놓기만 하고 다이나믹 프로그래밍을 위해 활용하지 않을 수도 있습니다.

## 메모이제이션 동작 분석 (피보나치 수열)

- 메모이제이션을 이용하는 경우 피보나치 수열 함수의 시간 복잡도는 O(N)입니다.

## 다이나믹 프로그래밍 vs 분할 정복

- 다이나믹 프로그래밍과 분할 정복은 모두 **최적 부분 구조**를 가질 때 사용할 수 있습니다.
  - 큰 문제를 작은 문제로 나눌 수 있으며 작은 문제의 답을 모아서 큰 문제를 해결할 수 있는 상황
- 다이나믹 프로그래밍과 분할 정복의 차이점은 **부분 문제의 중복**입니다.
  - 다이나믹 프로그래밍 문제에서는 각 부분 문제들이 서로 영향을 미치며 부분 문제가 중복됩니다.
  - 분할 정복 문제에서는 동일한 부분 문제가 반복적으로 계산되지 않습니다.

### 다이나믹 프로그래밍 문제에 접근하는 방법

- 주어진 문제가 **다이나믹 프로그래밍 유형임을 파악**하는 것이 중요합니다.
- 가장 먼저 그리디, 구현, 완전 탐색 등의 아이디어로 문제를 해결할 수 있는지 검토할 수 있습니다.
  - 다른 알고리즘으로 풀이 방법이 떠오르지 않으면 다이나믹 프로그래밍을 고려해 봅시다.
- 일단 재귀 함수로 비효율적인 완전 탐색 프로그램을 작성한 뒤에 (탑다운) 작은 문제에서 구한 답이 큰 문제에서 그대로 사용될 수 있으면, 코드를 개선하는 방법을 사용할 수 있습니다.
- <u>일반적인 코딩 테스트 수준에서는 기본 유형의 다이나믹 프로그래밍 문제가 출제</u>되는 경우가 많습니다.



# 그리디 알고리즘

- 그리디 알고리즘(탐욕법)은 **현재 상황에서 지금 당장 좋은 것만 고르는 방법**을 의미합니다.
- 일반적인 그리디 알고리즘은 문제를 풀기 위한 최소한의 아이디어를 떠올릴 수 있는 능력을 요구합니다.
- 그리디 해법은 그 정당성 분석이 중요합니다.
  - 단순히 가장 좋아 보이는 것을 반복적으로 선택해도 최적의 해를 구할 수 있는지 검토합니다. 

- 일반적인 상황에서 그리디 알고리즘은 최적의 해를 보장할 수 없을 때가 많습니다.
- 하지만 코딩 테스트에서의 대부분의 그리디 문제는 탐욕법으로 얻은 해가 최적의 해가 되는 상황에서, 이를 추론할 수 있어야 풀리도록 출제됩니다.
